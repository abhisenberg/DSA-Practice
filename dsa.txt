Given an array of integers, find two numbers such that they add up to a specific target. Return their indices.; Use a hash map to store each element's value and index. For each number, check if (target - current number) exists in the hash map. Time complexity: O(n), Space complexity: O(n). Optimal because it requires only one pass through the array.
Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. A string is valid if opening brackets are closed by the same type of brackets and in the correct order.; Use a stack to keep track of opening brackets and match them with closing brackets as they appear. Time complexity: O(n), Space complexity: O(n). Stack is ideal because brackets must be closed in the reverse order they were opened (LIFO principle).
Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.; Use a dummy head node with an iterative approach, comparing values from both lists and building the merged list. Time complexity: O(n+m), Space complexity: O(1) excluding the output list. This approach is optimal because we only need to traverse each list once.
You are given an array of prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve by buying once and selling once. You cannot sell before buying.; Use a single-pass approach tracking the minimum price seen so far and maximum profit possible. Time complexity: O(n), Space complexity: O(1). This is optimal as we only need to scan the array once while keeping track of two variables.
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.; Use Kadane's algorithm to track current sum and maximum sum. If current sum becomes negative, reset to 0. Time complexity: O(n), Space complexity: O(1). Optimal because we can find the solution in a single pass.
Reverse a singly linked list. Given the head of a linked list, return the reversed list.; Use iterative approach with three pointers (prev, current, next) to reverse links or use a recursive approach. Time complexity: O(n), Space complexity: O(1) for iterative, O(n) for recursive due to call stack. Iterative approach is preferred for space efficiency.
Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.; Use a hash set to track seen elements. Return true immediately if we encounter an element already in the set. Time complexity: O(n), Space complexity: O(n). Hash set provides O(1) lookups making it ideal for duplicate checking.
Given two strings s and t, return true if t is an anagram of s, and false otherwise. An anagram is a word formed by rearranging the letters of another word using all original letters exactly once.; Use either frequency counter (hash map) or sorted string comparison. Count character occurrences in both strings and compare. Time complexity: O(n), Space complexity: O(1) as there are only 26 letters. Alternatively, sorting both strings takes O(n log n) time.
Invert a binary tree (swap left and right children for all nodes).; Use recursive or iterative (queue-based) approach to swap left and right children for each node. Time complexity: O(n) to visit each node once, Space complexity: O(h) where h is tree height for recursive approach (due to call stack).
You are climbing a staircase that has n steps. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?; Use dynamic programming (bottom-up) or recursion with memoization (top-down) to calculate Fibonacci sequence. Time complexity: O(n), Space complexity: O(n) or can be optimized to O(1) by only storing the last two values. The problem reduces to Fibonacci because f(n) = f(n-1) + f(n-2).
Given the roots of two binary trees p and q, write a function to check if they are the same tree (structurally identical and nodes have the same value).; Use recursive DFS or iterative BFS to compare corresponding nodes. If at any point the nodes differ in value or structure, return false. Time complexity: O(n), Space complexity: O(h) where h is tree height.
Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.; Use binary search with two pointers (left and right). When the search ends, if target isn't found, left pointer indicates insertion position. Time complexity: O(log n), Space complexity: O(1). Binary search is optimal for searching sorted arrays.
Given the root of a binary tree, find its maximum depth (number of nodes along the longest path from root to furthest leaf).; Use recursive DFS (1 + max(depth(left), depth(right))) or iterative BFS with level tracking. Time complexity: O(n), Space complexity: O(h) where h is tree height for recursive approach.
Implement a queue using two stacks. The queue should support all functions of a normal queue (push, peek, pop, and empty).; Use two stacks: one for enqueue (push), another for dequeue operations. For dequeue, if second stack is empty, pop all elements from first stack and push to second stack (reversing the order). Time complexity: O(1) amortized for all operations, Space complexity: O(n).
Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.; Use BST properties to navigate down the tree - if both values < current node, go left; if both > current node, go right; otherwise, current node is LCA. Time complexity: O(h) where h is tree height, Space complexity: O(1) for iterative approach.
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each node contains a single digit. Add the two numbers and return the sum as a linked list.; Use dummy head node and iterate through both lists simultaneously, handling carry. Time complexity: O(max(n,m)), Space complexity: O(max(n,m)) for result. This approach simulates elementary addition.
Given an integer array nums, return an array answer such that answer[i] is equal to the product of all elements of nums except nums[i]. Solve without division and in O(n) time.; Use prefix and postfix products: create two arrays containing running products from left and right, then multiply corresponding values. Time complexity: O(n), Space complexity: O(1) excluding output array if we compute products on the fly.
Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.; Sort array, then for each element, use two pointers technique on remaining elements. Time complexity: O(n²), Space complexity: O(1) excluding output. Sorting enables efficient two-pointer approach to find pairs that sum to the negative of the current element.
Design and implement a data structure for Least Recently Used (LRU) cache. It should support get and put operations with O(1) time complexity.; Use a hash map for O(1) lookups combined with a doubly linked list for O(1) insertions/deletions from either end. The hash map maps keys to nodes in the linked list. Time complexity: O(1) for both get and put operations.
Given an m x n 2D binary grid which represents a map of '1's (land) and '0's (water), return the number of islands (connected land cells).; Use DFS or BFS to explore and mark connected land cells as visited. Each time we find an unvisited land cell, increment island count and explore all connected land cells. Time complexity: O(m×n), Space complexity: O(m×n) in worst case for recursive call stack.
There are a total of n courses you have to take, labeled from 0 to n-1. Some courses have prerequisites. Given the prerequisites as pairs, determine if it's possible to finish all courses.; Use topological sort (Kahn's algorithm) or DFS to detect cycles in the directed graph. If a cycle exists, it's impossible to complete all courses. Time complexity: O(V+E) where V is vertices and E is edges, Space complexity: O(V+E).
Implement a trie (prefix tree) with insert, search, and startsWith methods.; Use a tree-like data structure with nodes containing children pointers (usually a hash map) and isEndOfWord flag. Time complexity: O(L) where L is key length for all operations, Space complexity: O(N*L) where N is number of keys.
Given an m x n board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring.; Use backtracking with DFS to explore adjacent cells in the grid. Mark visited cells temporarily during exploration. Time complexity: O(m×n×4ᴸ) where L is word length, Space complexity: O(L) for recursion stack.
Design an algorithm to serialize and deserialize a binary tree.; Use preorder traversal with special markers for null nodes. For serialization, append node values and markers to a string. For deserialization, parse the string and reconstruct the tree. Time complexity: O(n), Space complexity: O(n) for both operations.
Implement a data structure that can find the median of a stream of integers. The median is the middle value or average of two middle values for even-length streams.; Use two heaps: max heap for lower half, min heap for upper half. Balance heaps after each insertion to keep size difference ≤1. Time complexity: O(log n) for insertions, O(1) for finding median, Space complexity: O(n).
Given a string s, find the length of the longest substring without repeating characters.; Use sliding window technique with a hash map to track character positions. When encountering a repeated character, move left pointer to position after previous occurrence. Time complexity: O(n), Space complexity: O(min(m,n)) where m is alphabet size.
Given a string s, return the longest palindromic substring in s.; Use either (1) Expand around center approach: try each position as potential center of palindrome, or (2) Dynamic programming with a 2D table. Time complexity: O(n²), Space complexity: O(1) for approach 1, O(n²) for approach 2. Expand around center is usually preferred for space efficiency.
Given an m x n grid of characters and a word, return true if the word can be built one letter at a time by traveling from one cell to an adjacent cell horizontally or vertically. Each cell can only be used once.; Use backtracking with DFS similar to word search, but track the grid of visited cells. Time complexity: O(m×n×4ᴸ) where L is word length, Space complexity: O(m×n) for visited grid plus recursion stack.
Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals and return the non-overlapping intervals that cover all the intervals in the input.; Sort intervals by start time, then merge overlapping intervals in a single pass. Time complexity: O(n log n) due to sorting, Space complexity: O(n) for output. Sorting makes it easy to identify overlaps.
Given a linked list, determine if it has a cycle. A cycle occurs when a node's next pointer points to a node earlier in the list.; Use Floyd's Tortoise and Hare algorithm (slow and fast pointers). If there's a cycle, the fast pointer will eventually catch up to the slow pointer. Time complexity: O(n), Space complexity: O(1). This approach is optimal as it uses constant extra space.
Given a non-empty array of integers nums, every element appears twice except for one. Find that single element.; Use XOR operation on all elements. Since a⊕a=0 and a⊕0=a, the result will be the unique element. Time complexity: O(n), Space complexity: O(1). XOR approach is optimal as it requires only one pass and constant space.
Given a string s and pattern p, implement wildcard pattern matching with '?' (matches any single character) and '*' (matches any sequence of characters).; Use dynamic programming to build a 2D table or greedy approach with backtracking. Time complexity: O(m×n) for DP approach, Space complexity: O(m×n) or can be optimized to O(n).
Given an m x n matrix, return all elements of the matrix in spiral order (clockwise from outside to inside).; Use simulation with four pointers (top, right, bottom, left) and traverse the matrix in spiral fashion, shrinking the boundaries after completing each direction. Time complexity: O(m×n), Space complexity: O(1) excluding output.
Given a collection of candidate numbers and a target sum, find all unique combinations where chosen numbers sum to target. Each number may be used only once and the solution set must not contain duplicate combinations.; Use backtracking with sorting to handle duplicates. Skip adjacent duplicates to avoid duplicate combinations. Time complexity: O(2ⁿ) in worst case, Space complexity: O(n) for recursion stack.
Given a non-empty binary tree, find the maximum path sum. A path is any sequence of nodes where each pair of adjacent nodes has an edge connecting them.; Use recursive DFS to compute the maximum path sum that passes through each node. Track global maximum while computing max gain from subtrees. Time complexity: O(n), Space complexity: O(h) where h is tree height.
Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. The sequence must be strictly increasing by 1 each time.; Use hash set to store all numbers, then for each number that could start a sequence (no number-1 in set), count consecutive numbers. Time complexity: O(n), Space complexity: O(n). This approach checks each sequence only once.
Given an array of integers and an integer k, find the number of continuous subarrays whose sum equals k.; Use prefix sum with hash map to track cumulative sum frequencies. For each prefix sum, check if (prefix sum - k) exists in map. Time complexity: O(n), Space complexity: O(n). This approach efficiently finds all valid subarrays in one pass.
Given an array of non-negative integers nums, arrange them such that they form the largest number when concatenated.; Sort the array using a custom comparator that compares strings s1+s2 vs s2+s1. Time complexity: O(n log n) for sorting, Space complexity: O(n) for storing string representations. This ensures optimal arrangement.
Given a binary tree, check whether it is a mirror of itself (symmetric around its center).; Use recursive or iterative approach to compare corresponding nodes in left and right subtrees. Time complexity: O(n), Space complexity: O(h) where h is tree height for recursive approach.
Convert a sorted array to a height-balanced binary search tree (a binary tree in which the depth of the two subtrees of every node never differ by more than 1).; Use recursive divide-and-conquer approach. Choose middle element as root and recursively build left and right subtrees. Time complexity: O(n), Space complexity: O(log n) for balanced tree recursion stack.
Given a list of daily temperatures, return a list such that, for each day, shows how many days you would have to wait until a warmer temperature.; Use a stack to keep track of indices of temperatures. Pop when finding a warmer temperature and calculate the waiting days. Time complexity: O(n), Space complexity: O(n) in worst case. This monotonic stack approach processes each element at most twice.
Given the root of a binary tree, calculate the vertical order traversal (nodes grouped by their horizontal distance from root, sorted by level and value).; Use BFS with a hash map to group nodes by column. Store coordinates (row,col) for each node and sort within each column. Time complexity: O(n log n) due to sorting, Space complexity: O(n).
Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing.; Use either (1) Sum formula: n*(n+1)/2 - actual sum, or (2) XOR approach: XOR all numbers from 0 to n and all numbers in array. Time complexity: O(n), Space complexity: O(1). These approaches avoid using extra space.
Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.; Use binary search on the shorter array to find the correct partition point. Time complexity: O(log(min(m,n))), Space complexity: O(1). This approach is optimal as it doesn't require merging arrays.
Given a string s, find if it can be segmented into a space-separated sequence of dictionary words.; Use dynamic programming to build a 1D array where dp[i] indicates whether substring(0,i) can be segmented. Time complexity: O(n²×m) where m is dictionary lookup time, Space complexity: O(n).
Find the kth largest element in an unsorted array.; Use QuickSelect algorithm (average O(n) time) or min-heap of size k (O(n log k) time). QuickSelect is faster on average but has worst-case O(n²). Heap approach has guaranteed O(n log k) which is often preferred in interviews.
Given a list of accounts where each element accounts[i] is a list [name, email1, email2, ...], merge accounts belonging to the same person (accounts with same name and at least one common email).; Use Union-Find (Disjoint Set) with a hash map to group emails by owner. Time complexity: O(n log n) where n is total emails, Space complexity: O(n). Union-Find efficiently handles the merging operations.
Implement a thread-safe bounded blocking queue that has blocking put and take methods.; Use synchronization primitives (mutex, semaphores) to implement thread safety. Use semaphores to track available slots and filled slots, with mutex to protect the critical section. This ensures proper producer-consumer synchronization.
Design and implement a data structure for a Least Frequently Used (LFU) cache with O(1) operations.; Use multiple hash maps: one to map keys to values, one to map keys to frequencies, and one to map frequencies to sets of keys. Time complexity: O(1) for all operations, Space complexity: O(capacity). This complex structure enables efficient tracking of usage frequency.
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water can be trapped after raining.; Use two-pointer approach (left and right) with tracking left_max and right_max walls. Time complexity: O(n), Space complexity: O(1). This approach avoids pre-computing arrays of maximal heights.
Given a 2D board of characters and a list of words, return all words that can be built from the board using Trie.; Use Trie to store all words, then perform backtracking DFS on the board using the Trie for efficient prefix checking. Time complexity: O(m×n×4ᴸ) where L is max word length, Space complexity: O(total characters in all words).
Given a set of non-overlapping intervals and a new interval, insert the new interval into the intervals at the correct position and merge if necessary.; Linear scan to find the correct position, handling three cases: (1) intervals before new interval, (2) intervals that overlap with new interval, (3) intervals after new interval. Time complexity: O(n), Space complexity: O(n) for output.